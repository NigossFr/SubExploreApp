using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using SubExplore.DataAccess;
using SubExplore.Models.Enums;

namespace SubExplore.Services.Implementations
{
    /// <summary>
    /// Service pour diagnostiquer et r√©parer les probl√®mes de types de spots
    /// </summary>
    public class SpotTypeDiagnosticService
    {
        private readonly SubExploreDbContext _context;
        private readonly ILogger<SpotTypeDiagnosticService> _logger;

        public SpotTypeDiagnosticService(SubExploreDbContext context, ILogger<SpotTypeDiagnosticService> logger)
        {
            _context = context;
            _logger = logger;
        }

        /// <summary>
        /// Diagnostique complet de l'√©tat des types de spots et spots
        /// </summary>
        public async Task<string> DiagnoseSpotTypesAsync()
        {
            try
            {
                var report = "=== DIAGNOSTIC COMPLET DES TYPES DE SPOTS ===\n\n";

                // 1. Types de spots actifs
                var activeSpotTypes = await _context.SpotTypes
                    .Where(st => st.IsActive)
                    .OrderBy(st => st.Category)
                    .ThenBy(st => st.Name)
                    .ToListAsync();

                report += "üìã TYPES DE SPOTS ACTIFS:\n";
                foreach (var type in activeSpotTypes)
                {
                    var categoryName = type.Category switch
                    {
                        ActivityCategory.Activity => "Activit√©s",
                        ActivityCategory.Structure => "Structures", 
                        ActivityCategory.Shop => "Boutiques",
                        ActivityCategory.Other => "Autres",
                        _ => $"Cat{(int)type.Category}"
                    };
                    report += $"  ‚Ä¢ {type.Name} (ID:{type.Id}) ‚Üí {categoryName} ({(int)type.Category})\n";
                }

                // 2. Spots existants et leurs types
                var spots = await _context.Spots
                    .Include(s => s.Type)
                    .OrderBy(s => s.Name)
                    .ToListAsync();

                report += "\nüìç SPOTS ET LEURS TYPES:\n";
                foreach (var spot in spots)
                {
                    var typeName = spot.Type?.Name ?? "TYPE MANQUANT";
                    var typeActive = spot.Type?.IsActive ?? false;
                    var status = typeActive ? "‚úì" : "‚ùå INACTIF";
                    report += $"  ‚Ä¢ {spot.Name} ‚Üí {typeName} (ID:{spot.TypeId}) {status}\n";
                }

                // 3. Analyse par cat√©gorie pour le filtrage
                report += "\nüîç ANALYSE DU FILTRAGE:\n";

                var activitesSpots = spots.Where(s => s.Type != null && s.Type.IsActive && 
                    (s.Type.Category == ActivityCategory.Activity ||
                     s.Type.Name.Contains("Plong√©e") || s.Type.Name.Contains("Apn√©e") || 
                     s.Type.Name.Contains("Randonn√©e") || s.Type.Name.Contains("Photo"))).ToList();
                report += $"  Activit√©s: {activitesSpots.Count} spots\n";

                var structuresSpots = spots.Where(s => s.Type != null && s.Type.IsActive && 
                    (s.Type.Category == ActivityCategory.Structure ||
                     s.Type.Name.Contains("Club") || s.Type.Name.Contains("Professionnel") || 
                     s.Type.Name.Contains("Base"))).ToList();
                report += $"  Structures: {structuresSpots.Count} spots\n";

                var boutiquesSpots = spots.Where(s => s.Type != null && s.Type.IsActive && 
                    (s.Type.Category == ActivityCategory.Shop ||
                     s.Type.Name.Contains("Boutique"))).ToList();
                report += $"  Boutiques: {boutiquesSpots.Count} spots\n";

                // 4. Probl√®mes d√©tect√©s
                report += "\nüö® PROBL√àMES D√âTECT√âS:\n";
                var problems = 0;

                // Spots avec types inactifs
                var spotsWithInactiveTypes = spots.Where(s => s.Type == null || !s.Type.IsActive).ToList();
                if (spotsWithInactiveTypes.Any())
                {
                    problems++;
                    report += $"  ‚ùå {spotsWithInactiveTypes.Count} spots ont des types inactifs:\n";
                    foreach (var spot in spotsWithInactiveTypes)
                    {
                        report += $"     ‚Ä¢ {spot.Name} (TypeId: {spot.TypeId})\n";
                    }
                }

                // Types avec mauvaise cat√©gorie
                var typesWithBadCategory = activeSpotTypes.Where(t => 
                    (t.Name.Contains("Boutique") && t.Category != ActivityCategory.Shop) ||
                    (t.Name.Contains("Club") && t.Category != ActivityCategory.Structure) ||
                    (t.Name.Contains("Plong√©e") && t.Category != ActivityCategory.Activity)).ToList();
                
                if (typesWithBadCategory.Any())
                {
                    problems++;
                    report += $"  ‚ùå {typesWithBadCategory.Count} types ont une cat√©gorie incorrecte:\n";
                    foreach (var type in typesWithBadCategory)
                    {
                        report += $"     ‚Ä¢ {type.Name} est en cat√©gorie {(int)type.Category} au lieu de la bonne\n";
                    }
                }

                if (problems == 0)
                {
                    report += "  ‚úÖ Aucun probl√®me d√©tect√©\n";
                }

                // 5. Recommandations
                report += "\nüí° RECOMMANDATIONS:\n";
                if (problems > 0)
                {
                    report += "  üîß Ex√©cuter SpotTypeMigrationService.ExecuteMigrationAsync()\n";
                    report += "  üîß Puis SpotTypeDiagnosticService.RepairSpotTypesAsync()\n";
                    report += "  üîÑ Red√©marrer l'application apr√®s r√©paration\n";
                }
                else
                {
                    report += "  ‚úÖ Syst√®me en bon √©tat - aucune action requise\n";
                }

                report += "\n=== FIN DU DIAGNOSTIC ===";
                return report;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erreur lors du diagnostic des types de spots");
                return $"‚ùå Erreur lors du diagnostic: {ex.Message}";
            }
        }

        /// <summary>
        /// R√©pare automatiquement les probl√®mes de types de spots
        /// </summary>
        public async Task<bool> RepairSpotTypesAsync()
        {
            try
            {
                _logger.LogInformation("üîß D√©but de la r√©paration des types de spots...");

                // 1. Identifier et d√©sactiver les doublons
                var allTypes = await _context.SpotTypes.ToListAsync();
                var duplicateNames = allTypes.GroupBy(t => t.Name)
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key)
                    .ToList();

                foreach (var duplicateName in duplicateNames)
                {
                    var duplicates = allTypes.Where(t => t.Name == duplicateName).OrderByDescending(t => t.Id).ToList();
                    var keepType = duplicates.First(); // Garder le plus r√©cent
                    var removeTypes = duplicates.Skip(1).ToList();

                    _logger.LogInformation($"Doublon d√©tect√© pour '{duplicateName}' - Garder ID:{keepType.Id}, Supprimer: {string.Join(",", removeTypes.Select(t => t.Id))}");

                    // Mettre √† jour les spots qui pointent vers les anciens types
                    foreach (var oldType in removeTypes)
                    {
                        var spotsToUpdate = await _context.Spots.Where(s => s.TypeId == oldType.Id).ToListAsync();
                        foreach (var spot in spotsToUpdate)
                        {
                            spot.TypeId = keepType.Id;
                            _logger.LogInformation($"Spot '{spot.Name}' mis √† jour: Type {oldType.Id} ‚Üí {keepType.Id}");
                        }
                        
                        // D√©sactiver l'ancien type
                        oldType.IsActive = false;
                    }
                }

                await _context.SaveChangesAsync();
                _logger.LogInformation("‚úÖ R√©paration des doublons termin√©e");

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Erreur lors de la r√©paration des types de spots");
                return false;
            }
        }

        /// <summary>
        /// Validates the complete spot type ecosystem for MySpotsPage compatibility
        /// </summary>
        public async Task<bool> ValidateSpotTypeEcosystemAsync()
        {
            try
            {
                _logger.LogInformation("üîç Validating complete spot type ecosystem...");
                
                // 1. Check if core spot types exist and are active
                var requiredTypes = new[] { "Apn√©e", "Photo sous-marine", "Plong√©e bouteille", "Randonn√©e sous-marine" };
                var activeTypes = await _context.SpotTypes
                    .Where(st => st.IsActive && requiredTypes.Contains(st.Name))
                    .Select(st => st.Name)
                    .ToListAsync();

                var missingTypes = requiredTypes.Except(activeTypes).ToList();
                if (missingTypes.Any())
                {
                    _logger.LogError("‚ùå Missing required spot types: {MissingTypes}", string.Join(", ", missingTypes));
                    return false;
                }

                // 2. Check for orphaned spots (spots with invalid TypeId)
                var orphanedSpots = await _context.Spots
                    .Where(s => !_context.SpotTypes.Any(st => st.Id == s.TypeId && st.IsActive))
                    .CountAsync();

                if (orphanedSpots > 0)
                {
                    _logger.LogWarning("‚ö†Ô∏è Found {OrphanedSpots} spots with invalid/inactive TypeId", orphanedSpots);
                }

                // 3. Check database constraints and foreign keys
                var spotsWithNullType = await _context.Spots
                    .Where(s => s.TypeId == 0 || s.TypeId == null)
                    .CountAsync();

                if (spotsWithNullType > 0)
                {
                    _logger.LogError("‚ùå Found {Count} spots with null TypeId", spotsWithNullType);
                    return false;
                }

                // 4. Validate MySpotsPage can load properly
                var testUserId = 1; // Admin user
                var userSpots = await _context.Spots
                    .Include(s => s.Type)
                    .Where(s => s.CreatorId == testUserId && s.Type != null && s.Type.IsActive)
                    .CountAsync();

                _logger.LogInformation("‚úÖ Spot type ecosystem validation complete:");
                _logger.LogInformation("  - Required types present: {RequiredTypes}", string.Join(", ", activeTypes));
                _logger.LogInformation("  - Orphaned spots: {OrphanedSpots}", orphanedSpots);
                _logger.LogInformation("  - Spots with null types: {NullTypeSpots}", spotsWithNullType);
                _logger.LogInformation("  - Test user spots loadable: {UserSpots}", userSpots);

                return orphanedSpots == 0 && spotsWithNullType == 0;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error validating spot type ecosystem");
                return false;
            }
        }
    }
}